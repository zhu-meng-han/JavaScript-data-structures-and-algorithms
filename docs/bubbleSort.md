
### 基本概念

> 冒泡排序比较任何两个相邻的项，如果第一个比第二个大，则交换它们。元素项向上移动至 正确的顺序，就好像气泡升至表面一样，冒泡排序因此得名。

人们开始学习排序算法时，通常都先学冒泡算法，因为它在所有排序算法中最简单。然而，从运行时间的角度来看，冒泡排序是最差的一个，接下来你会知晓原因。

### 算法步骤

* 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
* 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。
* 针对所有的元素重复以上的步骤，除了最后一个。
* 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

冒泡排序对有 `n` 个元素的项目平均需要 **`O(n²)`** 次比较次数，它可以原地排序，并且是能简单实现的几种排序算法之一，但是它对于少数元素之外的数列排序是很没有效率的。

* 最佳情况： `T(n) = O(n)`
* 最差情况： `T(n) = O(n²)`
* 平均情况： `T(n) = O(n²)`

### 动图演示

![](_media/sort-2.gif)

### 代码示例：

```js
function bubbleSort(arr) {
  const len = arr.length;
  for (let i = 0; i< len; ++i) {
    for (let j = 0; j < len - 1 - i; ++j) {
      if (arr[j] > arr[j + 1]) { // 相邻元素对比
        const temp = arr[j]; // 交换
        arr[j] = arr[j + 1];
        arr[j + 1] = temp;
      }
    }
  }
  return arr;
}

const arr = [3, 44 ,38 , 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];
console.log(bubbleSort(arr));
// [ 2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50 ]
```


